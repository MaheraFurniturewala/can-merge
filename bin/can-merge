#!/usr/bin/env node

'use strict';

const chalk = require('chalk');
const Yargs = require('yargs');
require('dotenv').config();
const getRepo = require('../utils/getRepo');
const getSHA = require('../utils/getSHA');

const runQuery = require('../utils/runQuery');
const evaluatePullRequest = require('../utils/evaluatePullRequest');

const {
	GITHUB_TOKEN,
	GH_TOKEN,
	NODE_ENV,
} = process.env;

const args = Yargs
	.usage('Usage: can-merge -p <pr> [-r <repo>]')
	.help()
	.strict()
	.options({
		pr: {
			alias: 'p',
			demandOption: false,
			describe: 'pull request',
			type: 'string',
		},
		repo: {
			alias: 'r',
			'default': getRepo(),
			demandOption: !getRepo(),
			describe: 'repository',
			type: 'string',
		},
		sha: {
			alias: 's',
			'default': getSHA(),
			describe: 'commit SHA',
			type: 'string',
		},
		token: {
			alias: 't',
			demandOption: !(GITHUB_TOKEN || GH_TOKEN),
			describe: 'github access token',
			type: 'string',
		},
	})
	.parse();

const token = args.token || GITHUB_TOKEN || GH_TOKEN;

runQuery(args.repo, args.pr, token).then((response) => {
	if (NODE_ENV === 'DEBUG') {
		console.log(JSON.stringify(response, null, 2));
	}

	const { pullRequest, pullRequests: { nodes: prNodes } } = response.repository;
	if (args.pr) {
		if (!pullRequest || !evaluatePullRequest(pullRequest, response)) {
			process.exit(1);
		}
	} else if (prNodes.length === 0) {
		console.error(chalk.redBright('No Pull Request Found'));
		process.exit(1);
	} else {
		prNodes.forEach((node) => {
			const resp = { repository: { pullRequest: node } };
			evaluatePullRequest(node, resp);
		});
	}
}).catch((error) => {
	console.error(chalk.redBright(error));
	process.exitCode = 1;
});

